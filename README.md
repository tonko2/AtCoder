# AtCoder

BeginnerContest

001

B: 四捨五入したいときは、Decimalに変換してからfloatにする必要がある

D: ソートして比較して、カバーしてない範囲がきたら出力

012

B: 0埋め複数 print('%02d:%02d:%02d' % (hh, mm, ss))

027

B: 解けなかった

030

B: AngleH = 30.0 * H + 0.5 * M. AngleM = 6.0 * M 時計苦手

046

A: 被ってる数はsetを使う

050

A: 10 + 10のような入力のときはa, o, b = input().split() または eval(input())

073

C: 解けなかった.

093:

A: ''.join(sorted(list(input())))

100:

B: 問題の意味がわからなかった

103:

C: 解けなかった. a[i] - 1が答え. lca(a[0], a[1], ..., a[n]) - 1

107:

B: all()は配列の中が全てTrueならTrue. list(zip(*field)）で、縦の配列を作れる

108

A: 組み合わせは掛け算
B: 回転行列, ベクトル

110

A: 降順 sorted(A, reverse=True)

111

A: 改行せずに出力 print(1, end='')
C: 解けた. collections.Counterを使えばもっとスッキリ. 2個飛ばしで配列作り直すのはV[::2]

118

C: 解けなかった. 2重ループしてgcdか、偶奇だと思ったが, 1ループのgcd.

120

C: 解けなかった. シミュレーションするのではなく、計算.

128

C: 解けなかった. 制約を見て, bitでできるのを考えるべき.

130

C: 解けなかった. 平行四辺形の対角線を通る直線は面接を二等分にする.

133

C: 解けた. (i * j) % 2019 = (i % 2019) * (i % 2019). 2019個以内に0になるものが存在するから0になったらforループから抜ける.

143

D: 解けなかった. 二分探索で, indexを求める.

144

D: 解けなかった. atanを使っててぇ

148

A: 入力で、横並びのA Bと縦並びのA Bのどっちか確認

151

C: defaultdict(int)は、d[(p, s)]のように、参照するだけでもkeyに含まれるのに注意.

152

C: 解けなかった. 4 -> 3 -> 1みたいに、降順になってる数列の最大の数を数えるのはループ一回で調べられる.

153

D: 解けた. メモ化再帰. from functools import lru_cache @lru_cache(maxsize=None)

156

B: NをK進数で表すとき np.base_repr(N, K))

161

B: 以上か未満を確認してから切り捨てを行う total // (4 * M)なのか、 -(-total // (4 * M)). もしくは両辺に4M掛けて少数計算をしない

162

A: math.pi

170

B: 2n + 4m = Y, n + m == Xのときは, 2X <= Y <= 4X and Y % 2 == 0

171

A: 大文字小文字の判定はstr.islower(), str.isupper()

179

C: 解けたけどO(N^2). A * B < Nは, for a in range(N) ans += (N - 1) // aでO(N)で解ける.

183

B: 相似 A:B = C:D, AD = BC

185

C: 解けなかった. 11箇所で切断はnC11.

187

A: 文字列をそれぞれ１文字のリストにし、整数にする map(int, str(A))

189

B: 不動小数点の演算は誤差を含むから両辺に100かけて整数演算する

193

C: 解けなかった. 2 ** 4 = 16, 4 ** 2 = 16を別々でカウントしてた.

194

B: 1行if res = min(res, A[i] + B[j] if i == j else max(A[i], B[j]))
C: 解けなかった. 現れる数字に限りがある場合は, setで保管して全探索.

195

B: 解けなかった. A * 個数 <= W <= B * 個数の範囲で最小と最大求める
C: 解けなかった. N以下のコンマの数を数える. 区間L = 1, R = 10を持って、 10倍ずつしていき、R <= Nだったら、 ans += (R - L) * comma, そうじゃなかったらL <= N < Rなので、(N - L + 1) * comma

197

A: index1とindex3のswapはindex2からindex3の文字列にindex1を足したもの S[1:] + S[0]

198

B: 同じ文字列のrepeatは "0" * N

200

A: 切り上げ -(-N // 100), 切り捨て N // 100
C: 解けなかった. Ai - Aj = 200 * nは, Ai % 200 と Aj % 200が一致する.

206

A: 除算の切り捨て //を使う

208

B: 階乗はfrom math import factorialのfactorialで計算

211

C: 解けなかった. DPの基礎.

214

C: 解けなかった. Heap使うまではよかったが、今いる場所 + 1だけ見ればいいのを、全部見てしまってTLE.

216

C: 解けなかった. 2倍にするタイミングと1追加するタイミングが大事.

218:

C: 解けなかった. 90°回転はlist(zip(*S[::-1])). 配列に'#'がいくつかある数え方は sum(1 for i in range(N) for j in range(N) if S[i][j] == '#')

219

B: １行で配列に詰める S = [input() for _ range(3)]. 文字列を結合して表示 print("".join(A))

221

C: 最大値を達成する分離の仕方において、分離後の2変数は数字列として見た時に単調非増加. bit全探索を使って2 ^ 9で調べられる. -> bitが立ってるところがleft, 立ってないとこがright ans = max(ans, left * right)

227

C: 解けなかった. 計算量をルートで見積もれなかった.

220

B: NをK進法に変える int(str(N), K) ex) int("101", 2) -> 5

223

C: 解けなかった. ぶつかる時間を求める -> 時間が0になるまで左から足していく. ans += min(A[i], t * B[i]), t -= min(t, A[i] / B[i]) 

226

B: Setにはタプルが入れられる
C: 横に単体の値と配列が来た場合の入力の受け取り方. t, k, *A = na()
D: 解けなかった. (x + 2, y + 4)の移動はxに1を2回, yに2を2回足せばいける. つまりGCDで割ったものをsetにつめる.

229

D: 解けなかった. 累積和 + 尺取法.

231

C: 二分探索

D: Union-Find

232

B: chr(65)で整数に対応するUnicodeに, ord('a')でUnicodeに対応する整数に変換するのをうまく使う

C: permutationを使う

D: BFSか、DP

233

D: HashMapのlogN検索を使って計算量を少なくする

E: 多倍長演算を一番小さい桁から繰り上げをうまく計算して実装

234

D: heapqを使う. heapq.heapify([3, 2, 1])で, 最小になるように入れ替える.

235

C: 辞書に複数の値を入れる. B = defaultdict(list)
E: クラスカル法でクエリ先読み, print(*ans, sep="\n")で配列の中身全部

236

B: 一つだけ奇数個しか現れない数があったらXORで求められる
C: if s in T:とやるとき, TがListだったらO(N), SetだったらO(logN)かかる
D: 2次元配列: [list(map(int, input().split())) for _ in range(2 * n - 1)]. 二人選ぶときは, indexの小さい方から１個見つけて, ループを抜けて. そのindex + 1からもう片方を見つけるというdfs.

237

D: 逆から見てdequeue
E: ポテンシャルを使ったダイクストラ

238

D: 解けなかった. x XOR y = x + y - 2(x AND y). x XOR y AND x AND y == 0

239

C: 解けなかった. 三平方使って長さ求めるとかではなく、格子点を求める必要がある. (x1, y1)からナイトが動ける範囲を選んで,(x1, y1)からの距離と, (x2, y2)からの距離が√5だったらYes.
E: 解けなかった. 部分木に, 子供を追加していく

240

D: stackは配列で表現できる. A = [[3, 1], [2, 1]]. topはA[-1], popはA.pop()
E: 解けなかった. 葉にindexを割り振って, 左右の部分木に存在する一番小さいindexと大きいindexを表示. 再帰が10 ** 5繰り返されるから, PyPyじゃTLE.

241:

D: 解けなかった. multiset

242

C: 解けなかった. DP. modがある時は基本DP.
D: 解けなかった. 二分木の性質を利用.

RegularContest

093:

C: 解けなかった. 問題を勘違いしてた. a - b - cの間でうまいこと引いて足す.

123:

A: 解けなかった. 2 * b = a + cに変形して考える.

131

A: 解けなかった. for回さずに, x = 10 ** 9 + A, 2 * x = 10 ** 9 * B + 2 * Aで、求まる.

132

A: 解けなかった. 実装せずに、パターンをみて解く.

133

136

B: 解けなかった. 転置数の偶奇.
D: 解けなかった. 解説見てもわからず.

GrandContest

011:

A: 解けなかった. ソートしてシミュレーション.

015:

A: 解けなかった. 5 + 5と4 + 6が一緒でという考えでなく、作れる数の範囲を考える.

017: 

A: 解けなかった. 数列の中に奇数があった場合、それ以外を足して、その奇数を含むか含めるかで偶数奇数を決めれる. 偶数も奇数も2^(N-1)通りの選び方がある.

023: 

A: 解けなかった. 部分列とか連続するというキーワードがあったら累積和を取る.

024:

A: 解けなかった. 偶奇で分岐しそうっていうのまではよかった. A, B, Cの変化に対しての相対的な量で比較する.

026

A: forの中のiを飛ばす時は、forではなくwhileを使う

A: 整数の辞書順を勘違いしない. [999, 1000, 1001, 1002]から1個とった最小の辞書順は[999, 1000, 1001]

028

A: 解けなかった. GCDとLCMでうまいことやる.

029:

A: 解けなかった. WBW -> WWBのように、左が白、右が黒にするように整列するときの入れ替え数を求める時は, Bが見つかったらcnt += 1, Wがみつかったらasn += cnt.

031:

A: 解けなかった. 位置を変えずにアルファベットを選ぶときは、選ぶ選ばないで考える.

032:

A: 解けなかった. 逆から見て, 一番右のものを取り除く.

034:

A: 解けなかった. ...があれば入れ替えられるなどの、考察が必要. 下界上界の境目が重要.

035:

A: 解けなかった. b = a XOR c, c = b XOR dから、a XOR d = 0を導く. あとは場合分け. 難しすぎ.

039:

A: 解けなかった. 全部が同じ, 最初と最後が別, 最初と最後が同じの３通りに場合分けする.

040:

A: 解けなかった. if S[i - 1] == '<': A[i] = A[i - 1] + 1. '>'はNから下がっていく. 最後に, C = [max(A[i], B[i]) for i in range(N)] print(sum(C)) 

041:

A: 解けなかった. 答えみても相当時間かかった. AとBの代入のタイミングが悪くてWA.

046:

A: 解けなかった. 角度を360回ずらせば元の位置に戻る.

054:

A: 解けなかった. 先頭と末尾が違かったら1, 一緒だったら, abcaaaa -> ab | caaaaaというように分けて2. abaaとかだったら-1.

080:

C: 解けたけど時間かかった.

MathAndAlgorithm

018: 辞書を使う時は, defaultdict(int)が良い. key見つからなくても0が入るから.

026: 期待値計算わからない

032: 二分探索. index = bisect_left(A, X) Xより１個先のindex

033: ベクトルの内積, 外積

035: 解けなかった. 交差する場合がわからなかった.

036: 解けなかった. 余弦定理, もしくは座標を求めて距離求める. 角度の求め方(radian): theta = math.radians(alpha)

Typical90

001: 解けなかった. 値を二分探索. 全区間が探索してる値以上であることが条件

003: 解けなかった. 木の直径.

004: list(zip(*grid))は遅い.

006: 解けなかった. あらかじめ, 今の文字より右の中で全てのアルファベットのindexを記憶. あとは貪欲に選んで、選んだindexと選んだ文字とKを比較してうまいことやる.

008: 解けなかった. 状態DP(耳DP). 選ぶ選ばないはdp[i + 1][j] += dp[i][j], dp[i + 1][j + 1] += dp[i][j]で表す.

010: SegTreeの[l, r)に注意.

012: 解けなかった. BFSと思いきやUF. ２次元配列を1次元配列で表してそれをノードとして登録する.

013: 解けた. 0とN-1からdijkstra

020: 解けなかった. log2(a) = b * log2(c) log2が取れる -> a = c ** b

021: 解けなかった. SCC(強連結成分分解)して、そのグループの数を数え上げる.

022: GCDまではよかったが解けなかった.

026: 解けなかった. 二部グラフの性質 (色彩数)を使う.

028: 解けなかった. 2次元imos法. 左上と右下に1足して, 左下と右上に-1する. あとは左から右、上から下で足していく.

029: 解けなかった. 遅延セグ木.

030: 解けなかった. 素数の逆数の和はO(loglogN) 1 / 2 + 1 / 3 + 1 / 5 + ... + 1 / N = O(loglogN). 調和級数. N <= 10^7なら O(N * loglogN)間に合う.

032: 解けなかった. (a, b) (c, d)と、ペアで考える時は順列生成して二つずつ取っていく.

033: 解けなかった. 問題の意味がわからなかった.

034: 解けなかった. 尺取り法. O(2 * N)

036: 解けなかった. マンハッタン距離の性質と45度回転を組み合わせる.

037: 解けなかった. DPをSegTreeで高速化. forの逆はfor i in range(W + 1)[::-1]

039: 解けなかった. 木DP. 子ノードの数を配列に保存するようdfsをして, 子ノードの数を|A| = min(dp[A[i]], dp[B[i]])とすると、|A| * (N - |A|)が, その辺を通る通り数. 

043: 解けなかった. 拡張BFS (01-BFS). 01-BFSの時はheapじゃなくdequeで良い.

044: 解けた. 配列の右シフトは change = (change - 1)% N

048: 解けなかった. 制約を見て、B, A-Bを詰めてsort.

055: 解けなかった. nC5のときは100 ** 5まで通る. 2 ^ 63 - 1を超えると計算に時間がかかりTLEの原因になる. 時間制限厳しいやつはmainを無くす.

058: 解けなかった. Cycle数を見つける.

061: dequeueの検索はO(1) q[x - 1]

063: 解けた. bit全探索とCounter

064: 解けなかった. 隣合う差を見ると, imos法みたいに考えると, l - 1とrだけ見れば良い.

069: 解けなかった. 組み合わせが解けると, K * (K - 1) * (K - 2)^(N - 2)が見えてきて, 繰り返し2乗法.

070: 解けなかった. 中央値.

072: 解けなかった. バックトラック.

075: 解けなかった. 素因数分解して、返ってきた配列のサイズが 1 << i以上だったらi

076: 解けなかった. 円環を列にして2倍にして累積和取って, 二分探索.

082: 解けなかった. 和の公式を使って, 全探索.

085: 解けなかった. 約数列挙. a*b = K // cは2重ループで求められる.

aising2020

C: 解けなかった. 愚直にやると, O(N * (100 ** 3))=O(10^10). NがO(10^4)なので, Nによらず、全探索して、答えを配列に詰める.

jsc2021

A: 切り上げはmath.ceil(x)

code-festival-2016-qualc

A: S.rindex("F")で, 右から最初に見つかるindexを返す

nomura2020

B: 解けなかった.

nikkei2019-qual

B: 解けなかった.

code-festival-2017-quala

B: 解けなかった. ボタン操作で反転させるやつは k * (M - l) + l * (N - k)で白黒の数カウントできる.

code-festival-2017-qualc

B: 想定解法で解けなかった. 各A[i]に対して、A[i]が偶数のときは,A[i] - 1, A[i] + 1は奇数. 3^N - 2^eが答え. eはA[i]が偶数であるiの個数をeとする.

code-festival-2017-final

B: 解けた. [4, 4, 3]や[3, 3, 3], [4, 3, 3]をOKにしたいときは各文字の出現回数の差をみる.

panasonic2020

C: 解けなかった. 4 * a * b < (c - a - b) ** 2まではいけたが, c - a - b < 0がNoがわからなかった.

keyence2019

C: 解けなかった. diff[-1]とdiff.pop(-1)をうまく使う.

caddi2018

C: 解けなかった. 素因数分解して、均等に掛ける. N = 4, P = 2^6 * 3^3 * 5 * 103^4の時, 2 * 103が答え.

cf16-final

B: 解けなかった. N以上の1 ~ Xまでの和を求めてその和 - Nの値を答えに入れなければ良い.

Memo:
bisect_left(A, x)は、Aのx未満の要素の個数
bisect_right(A, x)は、Aのx以下の要素の個数